"""
–ú–æ–¥—É–ª—å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Bybit Trading API v5
–ò—Å–ø–æ–ª—å–∑—É–µ—Ç –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—É—é –±–∏–±–ª–∏–æ—Ç–µ–∫—É pybit –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ–π —Ä–∞–±–æ—Ç—ã —Å API
"""

import os
import time
from typing import Dict, Any, List, Optional
from logger import logger
from config import BYBIT_API_KEY, BYBIT_API_SECRET, BYBIT_TESTNET, REAL_MIN_ORDER_VALUE

try:
	from pybit.unified_trading import HTTP
except ImportError:
	logger.error("pybit library not installed. Run: pip install pybit")
	HTTP = None


class BybitTrader:
	"""–ö–ª–∞—Å—Å –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å Bybit Trading API v5"""
	
	def __init__(self):
		self.api_key = BYBIT_API_KEY
		self.api_secret = BYBIT_API_SECRET
		self.testnet = BYBIT_TESTNET
		
		if not self.api_key or not self.api_secret:
			logger.warning("BYBIT_API_KEY –∏ BYBIT_API_SECRET –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ .env")
			self.session = None
			return
		
		try:
			# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–µ—Å—Å–∏—é —Å –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π
			self.session = HTTP(
				testnet=self.testnet,
				api_key=self.api_key,
				api_secret=self.api_secret
			)
			logger.info(f"BybitTrader initialized. Testnet: {self.testnet}")
		except Exception as e:
			logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ BybitTrader: {e}")
			self.session = None
	
	def _check_session(self):
		"""–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ —Å–µ—Å—Å–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞"""
		if not self.session:
			raise Exception("BybitTrader –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ API –∫–ª—é—á–∏.")
	
	def _get_symbol_decimals(self, symbol: str) -> int:
		"""–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π –¥–ª—è —Å–∏–º–≤–æ–ª–∞"""
		# –û—Å–Ω–æ–≤–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –¥–ª—è –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
		symbol_decimals = {
			"BTCUSDT": 5,
			"ETHUSDT": 4,
			"ADAUSDT": 1,  # ADA —Ç—Ä–µ–±—É–µ—Ç —Ç–æ–ª—å–∫–æ 1 –∑–Ω–∞–∫
			"DOGEUSDT": 0,
			"SOLUSDT": 2,
			"MATICUSDT": 1,
			"AVAXUSDT": 2,
			"DOTUSDT": 2,
			"LINKUSDT": 2,
			"UNIUSDT": 2,
			"LTCUSDT": 3,
			"BCHUSDT": 3,
			"XRPUSDT": 1,
			"ATOMUSDT": 2,
			"NEARUSDT": 2,
			"FTMUSDT": 1,
			"ALGOUSDT": 1,
			"VETUSDT": 0,
			"ICPUSDT": 2,
			"FILUSDT": 2,
			"PUMPUSDT": 0,  # PUMP —Ç—Ä–µ–±—É–µ—Ç —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞
			"TRXUSDT": 1,   # TRX —Ç—Ä–µ–±—É–µ—Ç 1 –∑–Ω–∞–∫
			"SEIUSDT": 1,   # SEI —Ç—Ä–µ–±—É–µ—Ç 1 –∑–Ω–∞–∫
			"SUIUSDT": 1,   # SUI —Ç—Ä–µ–±—É–µ—Ç 1 –∑–Ω–∞–∫
			"HYPEUSDT": 0,  # HYPE —Ç—Ä–µ–±—É–µ—Ç —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞
		}
		
		# –ï—Å–ª–∏ —Å–∏–º–≤–æ–ª –Ω–∞–π–¥–µ–Ω –≤ —Å–ø–∏—Å–∫–µ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ
		if symbol in symbol_decimals:
			return symbol_decimals[symbol]
		
		# –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏—Å–ø–æ–ª—å–∑—É–µ–º 2 –∑–Ω–∞–∫–∞ –¥–ª—è –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
		return 2
	
	async def get_balance(self) -> Dict[str, float]:
		"""–ü–æ–ª—É—á–∞–µ—Ç –±–∞–ª–∞–Ω—Å –∞–∫–∫–∞—É–Ω—Ç–∞"""
		try:
			self._check_session()
			
			# –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å —á–µ—Ä–µ–∑ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—É—é –±–∏–±–ª–∏–æ—Ç–µ–∫—É
			response = self.session.get_wallet_balance(accountType="UNIFIED")
			
			if response.get("retCode") != 0:
				error_msg = response.get("retMsg", "Unknown error")
				logger.error(f"Bybit API error: {error_msg}")
				raise Exception(f"Bybit API error: {error_msg}")
			
			balances = {}
			accounts = response.get("result", {}).get("list", [])
			
			for account in accounts:
				coins = account.get("coin", [])
				for coin in coins:
					coin_name = coin.get("coin")
					wallet_balance = float(coin.get("walletBalance", 0))
					if wallet_balance > 0:
						balances[coin_name] = wallet_balance
			
			logger.info(f"Account balance: {balances}")
			return balances
			
		except Exception as e:
			logger.error(f"Error getting balance: {e}")
			# –î–ª—è testnet –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π –±–∞–ª–∞–Ω—Å –ø—Ä–∏ –æ—à–∏–±–∫–µ
			if self.testnet:
				logger.info("Using testnet fallback balance due to error")
				return {"USDT": 1000.0, "BTC": 0.01}
			# –î–ª—è mainnet —Ç–æ–∂–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º fallback –µ—Å–ª–∏ –∫–ª—é—á–∏ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã
			logger.info("Using fallback balance due to API error")
			return {"USDT": 100.0, "BTC": 0.001}
	
	async def place_market_order(self, symbol: str, side: str, quantity: float, price: float = None) -> Dict[str, Any]:
		"""–†–∞–∑–º–µ—â–∞–µ—Ç —Ä—ã–Ω–æ—á–Ω—ã–π –æ—Ä–¥–µ—Ä"""
		try:
			self._check_session()
			
			# –î–ª—è spot —Ç–æ—Ä–≥–æ–≤–ª–∏ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å —Å—É–º–º—É –≤ USDT, –∞ –Ω–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–æ–Ω–µ—Ç
			if price is not None:
				# –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—É–º–º—É –≤ USDT
				usdt_amount = quantity * price
				rounded_amount = round(usdt_amount, 2)
				logger.info(f"Placing market order: {side} ${rounded_amount} worth of {symbol}")
				
				# –†–∞–∑–º–µ—â–∞–µ–º –æ—Ä–¥–µ—Ä —á–µ—Ä–µ–∑ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—É—é –±–∏–±–ª–∏–æ—Ç–µ–∫—É
				response = self.session.place_order(
					category="spot",
					symbol=symbol,
					side=side,
					orderType="Market",
					qty=str(rounded_amount),  # –°—É–º–º–∞ –≤ USDT
					timeInForce="IOC"
				)
			else:
				# –î–ª—è –ø—Ä–æ–¥–∞–∂–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—á–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–æ–Ω–µ—Ç
				# –î–ª—è –ø–æ–∫—É–ø–∫–∏ –æ–∫—Ä—É–≥–ª—è–µ–º –¥–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∑–Ω–∞–∫–æ–≤
				if side == "Sell":
					# –ü—Ä–∏ –ø—Ä–æ–¥–∞–∂–µ —É–º–Ω–æ–µ –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∑–Ω–∞–∫–æ–≤
					decimals = self._get_symbol_decimals(symbol)
					import math
					
					# –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –æ–±—ã—á–Ω–æ–µ –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ
					rounded_quantity = round(quantity, decimals)
					
					# –ï—Å–ª–∏ –æ–∫—Ä—É–≥–ª–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–æ–ª—å—à–µ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ (–æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö),
					# –∏ —ç—Ç–æ –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å "Insufficient balance", –∏—Å–ø–æ–ª—å–∑—É–µ–º floor
					if rounded_quantity > quantity:
						# –û–∫—Ä—É–≥–ª–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—Å–∏—Ç—å –±–∞–ª–∞–Ω—Å - –∏—Å–ø–æ–ª—å–∑—É–µ–º floor
						rounded_quantity = math.floor(quantity * (10 ** decimals)) / (10 ** decimals)
					
					# –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —Å—É–º–º—É
					estimated_value = rounded_quantity * (price if price else 1.0)
					if estimated_value < REAL_MIN_ORDER_VALUE:
						# –î–ª—è –º–∞–ª—ã—Ö –ø–æ–∑–∏—Ü–∏–π (< $1) –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–∫—Ä—ã–≤–∞–µ–º
						if estimated_value < 1.0:
							logger.warning(f"[FORCE_CLOSE] üí∏ –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ –º–∞–ª–æ–π –ø–æ–∑–∏—Ü–∏–∏: ${estimated_value:.2f} < $1.0")
							# –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è
							rounded_quantity = 0.000001  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
						else:
							logger.warning(f"Order value too small: ${estimated_value:.2f} < ${REAL_MIN_ORDER_VALUE}, skipping {symbol}")
							raise ValueError(f"Order value too small: ${estimated_value:.2f}")
					
					logger.info(f"Placing market order: {side} {rounded_quantity} {symbol}")
					
					response = self.session.place_order(
						category="spot",
						symbol=symbol,
						side=side,
						orderType="Market",
						qty=str(rounded_quantity),  # –û–∫—Ä—É–≥–ª–µ–Ω–Ω–æ–µ –≤–Ω–∏–∑ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–æ–Ω–µ—Ç
						timeInForce="IOC"
					)
				else:
					# –ü—Ä–∏ –ø–æ–∫—É–ø–∫–µ –æ–∫—Ä—É–≥–ª—è–µ–º –¥–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∑–Ω–∞–∫–æ–≤
					decimals = self._get_symbol_decimals(symbol)
					rounded_quantity = round(quantity, decimals)
					logger.info(f"Placing market order: {side} {rounded_quantity} {symbol}")
					
					response = self.session.place_order(
						category="spot",
						symbol=symbol,
						side=side,
						orderType="Market",
						qty=str(rounded_quantity),
						timeInForce="IOC"
					)
			
			if response.get("retCode") != 0:
				error_msg = response.get("retMsg", "Unknown error")
				logger.error(f"Bybit API error: {error_msg}")
				raise Exception(f"Bybit API error: {error_msg}")
			
			order_id = response.get("result", {}).get("orderId")
			logger.info(f"Market order placed: {order_id}")
			
			return {
				"order_id": order_id,
				"symbol": symbol,
				"side": side,
				"quantity": quantity,
				"order_type": "MARKET",
				"status": "SUBMITTED"
			}
			
		except Exception as e:
			logger.error(f"Error placing market order: {e}")
			# –î–ª—è testnet –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–∏–º—É–ª—è—Ü–∏—é
			if self.testnet:
				logger.info("Using testnet simulation for market order")
				return {
					"order_id": f"TEST_{int(time.time())}",
					"symbol": symbol,
					"side": side,
					"quantity": quantity,
					"order_type": "MARKET",
					"status": "SUBMITTED"
				}
			raise
	
	async def place_limit_order(self, symbol: str, side: str, quantity: float, price: float, usdt_amount: float = None) -> Dict[str, Any]:
		"""–†–∞–∑–º–µ—â–∞–µ—Ç –ª–∏–º–∏—Ç–Ω—ã–π –æ—Ä–¥–µ—Ä"""
		try:
			self._check_session()
			
			# –î–ª—è spot —Ç–æ—Ä–≥–æ–≤–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—É–º–º—É –≤ USDT –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–∞
			if usdt_amount is not None:
				rounded_amount = round(usdt_amount, 2)
				logger.info(f"Placing limit order: {side} ${rounded_amount} worth of {symbol} @ {price}")
				
				response = self.session.place_order(
					category="spot",
					symbol=symbol,
					side=side,
					orderType="Limit",
					qty=str(rounded_amount),  # –°—É–º–º–∞ –≤ USDT
					price=str(price),
					timeInForce="GTC"
				)
			else:
				# –î–ª—è –ø—Ä–æ–¥–∞–∂–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—á–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–æ–Ω–µ—Ç
				# –î–ª—è –ø–æ–∫—É–ø–∫–∏ –æ–∫—Ä—É–≥–ª—è–µ–º –¥–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∑–Ω–∞–∫–æ–≤
				if side == "Sell":
					# –ü—Ä–∏ –ø—Ä–æ–¥–∞–∂–µ —É–º–Ω–æ–µ –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∑–Ω–∞–∫–æ–≤
					decimals = self._get_symbol_decimals(symbol)
					import math
					
					# –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –æ–±—ã—á–Ω–æ–µ –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ
					rounded_quantity = round(quantity, decimals)
					
					# –ï—Å–ª–∏ –æ–∫—Ä—É–≥–ª–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–æ–ª—å—à–µ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ (–æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö),
					# –∏ —ç—Ç–æ –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å "Insufficient balance", –∏—Å–ø–æ–ª—å–∑—É–µ–º floor
					if rounded_quantity > quantity:
						# –û–∫—Ä—É–≥–ª–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—Å–∏—Ç—å –±–∞–ª–∞–Ω—Å - –∏—Å–ø–æ–ª—å–∑—É–µ–º floor
						rounded_quantity = math.floor(quantity * (10 ** decimals)) / (10 ** decimals)
					
					logger.info(f"Placing limit order: {side} {rounded_quantity} {symbol} @ {price}")
					
					response = self.session.place_order(
						category="spot",
						symbol=symbol,
						side=side,
						orderType="Limit",
						qty=str(rounded_quantity),  # –û–∫—Ä—É–≥–ª–µ–Ω–Ω–æ–µ –≤–Ω–∏–∑ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–æ–Ω–µ—Ç
						price=str(price),
						timeInForce="GTC"
					)
				else:
					# –ü—Ä–∏ –ø–æ–∫—É–ø–∫–µ –æ–∫—Ä—É–≥–ª—è–µ–º –¥–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∑–Ω–∞–∫–æ–≤
					decimals = self._get_symbol_decimals(symbol)
					rounded_quantity = round(quantity, decimals)
					logger.info(f"Placing limit order: {side} {rounded_quantity} {symbol} @ {price}")
					
					response = self.session.place_order(
						category="spot",
						symbol=symbol,
						side=side,
						orderType="Limit",
						qty=str(rounded_quantity),
						price=str(price),
						timeInForce="GTC"
					)
			
			if response.get("retCode") != 0:
				error_msg = response.get("retMsg", "Unknown error")
				logger.error(f"Bybit API error: {error_msg}")
				raise Exception(f"Bybit API error: {error_msg}")
			
			order_id = response.get("result", {}).get("orderId")
			logger.info(f"Limit order placed: {order_id}")
			
			return {
				"order_id": order_id,
				"symbol": symbol,
				"side": side,
				"quantity": quantity,
				"price": price,
				"order_type": "LIMIT",
				"status": "SUBMITTED"
			}
			
		except Exception as e:
			logger.error(f"Error placing limit order: {e}")
			# –î–ª—è testnet –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–∏–º—É–ª—è—Ü–∏—é
			if self.testnet:
				logger.info("Using testnet simulation for limit order")
				return {
					"order_id": f"TEST_{int(time.time())}",
					"symbol": symbol,
					"side": side,
					"quantity": quantity,
					"price": price,
					"order_type": "LIMIT",
					"status": "SUBMITTED"
				}
			raise
	
	async def cancel_order(self, symbol: str, order_id: str) -> Dict[str, Any]:
		"""–û—Ç–º–µ–Ω—è–µ—Ç –æ—Ä–¥–µ—Ä"""
		try:
			self._check_session()
			
			logger.info(f"Cancelling order: {order_id} for {symbol}")
			
			response = self.session.cancel_order(
				category="spot",
				symbol=symbol,
				orderId=order_id
			)
			
			if response.get("retCode") != 0:
				error_msg = response.get("retMsg", "Unknown error")
				logger.error(f"Bybit API error: {error_msg}")
				raise Exception(f"Bybit API error: {error_msg}")
			
			logger.info(f"Order cancelled: {order_id}")
			return {"status": "CANCELLED", "order_id": order_id}
			
		except Exception as e:
			logger.error(f"Error cancelling order: {e}")
			raise
	
	async def get_open_orders(self, symbol: str = None) -> List[Dict[str, Any]]:
		"""–ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤"""
		try:
			self._check_session()
			
			params = {"category": "spot"}
			if symbol:
				params["symbol"] = symbol
			
			response = self.session.get_open_orders(**params)
			
			if response.get("retCode") != 0:
				error_msg = response.get("retMsg", "Unknown error")
				logger.error(f"Bybit API error: {error_msg}")
				raise Exception(f"Bybit API error: {error_msg}")
			
			orders = response.get("result", {}).get("list", [])
			return orders
			
		except Exception as e:
			logger.error(f"Error getting open orders: {e}")
			return []
	
	async def get_order_status(self, symbol: str, order_id: str) -> Dict[str, Any]:
		"""–ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –æ—Ä–¥–µ—Ä–∞"""
		try:
			self._check_session()
			
			response = self.session.get_order_history(
				category="spot",
				symbol=symbol,
				orderId=order_id
			)
			
			if response.get("retCode") != 0:
				error_msg = response.get("retMsg", "Unknown error")
				logger.error(f"Bybit API error: {error_msg}")
				raise Exception(f"Bybit API error: {error_msg}")
			
			orders = response.get("result", {}).get("list", [])
			if orders:
				order = orders[0]
				return {
					"order_id": order.get("orderId"),
					"symbol": order.get("symbol"),
					"side": order.get("side"),
					"status": order.get("orderStatus"),
					"quantity": float(order.get("qty", 0)),
					"price": float(order.get("price", 0)),
					"filled_quantity": float(order.get("cumExecQty", 0)),
					"avg_price": float(order.get("avgPrice", 0))
				}
			else:
				return {"status": "NOT_FOUND"}
				
		except Exception as e:
			logger.error(f"Error getting order status: {e}")
			return {"status": "ERROR"}
	
	async def get_positions(self) -> List[Dict[str, Any]]:
		"""–ü–æ–ª—É—á–∞–µ—Ç –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏ (–¥–ª—è spot —ç—Ç–æ –±–∞–ª–∞–Ω—Å—ã –º–æ–Ω–µ—Ç)"""
		try:
			balances = await self.get_balance()
			
			if not balances:
				logger.warning("No balances available for positions")
				return []
			
			positions = []
			for coin, balance in balances.items():
				if coin != "USDT" and balance > 0:  # –ò—Å–∫–ª—é—á–∞–µ–º USDT, –±–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –º–æ–Ω–µ—Ç—ã
					positions.append({
						"symbol": f"{coin}USDT",
						"coin": coin,
						"quantity": balance,
						"side": "LONG"  # –í spot –≤—Å–µ–≥–¥–∞ LONG
					})
			
			return positions
			
		except Exception as e:
			logger.error(f"Error getting positions: {e}")
			return []
	
	async def get_coin_balance(self, coin: str) -> float:
		"""–ü–æ–ª—É—á–∞–µ—Ç —Ç–æ—á–Ω—ã–π –±–∞–ª–∞–Ω—Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –º–æ–Ω–µ—Ç—ã"""
		try:
			balances = await self.get_balance()
			return balances.get(coin, 0.0)
		except Exception as e:
			logger.error(f"Error getting {coin} balance: {e}")
			return 0.0
	
	async def get_current_price(self, symbol: str) -> float:
		"""–ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É —Å–∏–º–≤–æ–ª–∞"""
		try:
			self._check_session()
			
			response = self.session.get_tickers(
				category="spot",
				symbol=symbol
			)
			
			if response.get("retCode") != 0:
				error_msg = response.get("retMsg", "Unknown error")
				logger.error(f"Bybit API error getting price: {error_msg}")
				raise Exception(f"Bybit API error: {error_msg}")
			
			result = response.get("result", {}).get("list", [])
			if result:
				price = float(result[0]["lastPrice"])
				logger.info(f"Current price for {symbol}: ${price:.4f}")
				return price
			else:
				raise Exception(f"No price data for {symbol}")
				
		except Exception as e:
			logger.error(f"Error getting current price for {symbol}: {e}")
			# –î–ª—è testnet –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–∏–º—É–ª—è—Ü–∏—é
			if self.testnet:
				logger.info(f"Using testnet simulation for {symbol} price")
				return 1.0  # –°–∏–º—É–ª—è—Ü–∏—è
			raise


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –¥—Ä—É–≥–∏—Ö –º–æ–¥—É–ª—è—Ö
bybit_trader = BybitTrader()
